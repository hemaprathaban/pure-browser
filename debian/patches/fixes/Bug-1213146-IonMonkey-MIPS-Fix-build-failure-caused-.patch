From: Heiher <r@hev.cc>
Date: Sun, 1 Nov 2015 05:10:01 +0800
Subject: Bug 1213146 - IonMonkey: MIPS: Fix build failure caused by bug
 1194139. r=nbp

---
 js/src/jit/mips-shared/Architecture-mips-shared.h | 12 +++---
 js/src/jit/mips-shared/Assembler-mips-shared.h    | 38 -------------------
 js/src/jit/mips32/Architecture-mips32.cpp         | 17 +++++++++
 js/src/jit/mips32/Architecture-mips32.h           | 17 ---------
 js/src/jit/mips32/Assembler-mips32.h              | 46 +++++++++++++++++++----
 js/src/jit/mips64/Architecture-mips64.cpp         | 17 +++++++++
 js/src/jit/mips64/Architecture-mips64.h           | 17 ---------
 js/src/jit/mips64/Assembler-mips64.h              | 45 ++++++++++++++++++----
 8 files changed, 117 insertions(+), 92 deletions(-)

diff --git a/js/src/jit/mips-shared/Architecture-mips-shared.h b/js/src/jit/mips-shared/Architecture-mips-shared.h
index d436829..4b613dd 100644
--- a/js/src/jit/mips-shared/Architecture-mips-shared.h
+++ b/js/src/jit/mips-shared/Architecture-mips-shared.h
@@ -128,10 +128,10 @@ class Registers
         uintptr_t r;
     };
 
+    static const char * const RegNames[];
     static const char* GetName(Code code) {
         MOZ_ASSERT(code < Total);
-        static const char * const Names[] = REGISTERS_NAMES;
-        return Names[code];
+        return RegNames[code];
     }
     static const char* GetName(Encoding i) {
         return GetName(Code(i));
@@ -143,12 +143,12 @@ class Registers
     static const Encoding Invalid = invalid_reg;
 
     static const uint32_t Total = 32;
-    static const uint32_t Allocatable = REGISTERS_ALLOCATABLE;
+    static const uint32_t Allocatable;
 
     typedef uint32_t SetType;
     static const SetType AllMask = 0xffffffff;
     static const SetType SharedArgRegMask = (1 << a0) | (1 << a1) | (1 << a2) | (1 << a3);
-    static const SetType ArgRegMask = REGISTERS_ARGREGMASK;
+    static const SetType ArgRegMask;
 
     static const SetType VolatileMask =
         (1 << Registers::v0) |
@@ -200,11 +200,11 @@ class Registers
     static const SetType TempMask = VolatileMask & ~NonAllocatableMask;
 
     // Registers returned from a JS -> JS call.
-    static const SetType JSCallMask = REGISTERS_JSCALLMASK;
+    static const SetType JSCallMask;
 
     // Registers returned from a JS -> C call.
     static const SetType SharedCallMask = (1 << Registers::v0);
-    static const SetType CallMask = REGISTERS_CALLMASK;
+    static const SetType CallMask;
 
     static const SetType AllocatableMask = AllMask & ~NonAllocatableMask;
 
diff --git a/js/src/jit/mips-shared/Assembler-mips-shared.h b/js/src/jit/mips-shared/Assembler-mips-shared.h
index a390ef4..803247a 100644
--- a/js/src/jit/mips-shared/Assembler-mips-shared.h
+++ b/js/src/jit/mips-shared/Assembler-mips-shared.h
@@ -95,8 +95,6 @@ static MOZ_CONSTEXPR_VAR Register IntArgReg6 = a6;
 static MOZ_CONSTEXPR_VAR Register IntArgReg7 = a7;
 static MOZ_CONSTEXPR_VAR Register GlobalReg = s6; // used by Odin
 static MOZ_CONSTEXPR_VAR Register HeapReg = s7; // used by Odin
-static MOZ_CONSTEXPR_VAR Register CallTempNonArgRegs[] = CALL_TEMP_NON_ARG_REGS;
-static const uint32_t NumCallTempNonArgRegs = mozilla::ArrayLength(CallTempNonArgRegs);
 
 static MOZ_CONSTEXPR_VAR Register PreBarrierReg = a1;
 
@@ -1317,42 +1315,6 @@ class InstJump : public Instruction
     }
 };
 
-static const uint32_t NumIntArgRegs = NUM_INT_ARG_REGS;
-
-static inline bool
-GetIntArgReg(uint32_t usedArgSlots, Register* out)
-{
-    if (usedArgSlots < NumIntArgRegs) {
-        *out = Register::FromCode(a0.code() + usedArgSlots);
-        return true;
-    }
-    return false;
-}
-
-// Get a register in which we plan to put a quantity that will be used as an
-// integer argument. This differs from GetIntArgReg in that if we have no more
-// actual argument registers to use we will fall back on using whatever
-// CallTempReg* don't overlap the argument registers, and only fail once those
-// run out too.
-static inline bool
-GetTempRegForIntArg(uint32_t usedIntArgs, uint32_t usedFloatArgs, Register* out)
-{
-    // NOTE: We can't properly determine which regs are used if there are
-    // float arguments. If this is needed, we will have to guess.
-    MOZ_ASSERT(usedFloatArgs == 0);
-
-    if (GetIntArgReg(usedIntArgs, out))
-        return true;
-    // Unfortunately, we have to assume things about the point at which
-    // GetIntArgReg returns false, because we need to know how many registers it
-    // can allocate.
-    usedIntArgs -= NumIntArgRegs;
-    if (usedIntArgs >= NumCallTempNonArgRegs)
-        return false;
-    *out = CallTempNonArgRegs[usedIntArgs];
-    return true;
-}
-
 } // namespace jit
 } // namespace js
 
diff --git a/js/src/jit/mips32/Architecture-mips32.cpp b/js/src/jit/mips32/Architecture-mips32.cpp
index 549aa93..7aabb97 100644
--- a/js/src/jit/mips32/Architecture-mips32.cpp
+++ b/js/src/jit/mips32/Architecture-mips32.cpp
@@ -11,6 +11,23 @@
 namespace js {
 namespace jit {
 
+const char * const Registers::RegNames[] = { "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
+                                             "t0",   "t1", "t2", "t3", "t4", "t5", "t6", "t7",
+                                             "s0",   "s1", "s2", "s3", "s4", "s5", "s6", "s7",
+                                             "t8",   "t9", "k0", "k1", "gp", "sp", "fp", "ra" };
+
+const uint32_t Allocatable = 14;
+
+const Registers::SetType Registers::ArgRegMask = Registers::SharedArgRegMask;
+
+const Registers::SetType Registers::JSCallMask =
+    (1 << Registers::a2) |
+    (1 << Registers::a3);
+
+const Registers::SetType Registers::CallMask =
+    (1 << Registers::v0) |
+    (1 << Registers::v1);  // used for double-size returns
+
 FloatRegisters::Code
 FloatRegisters::FromName(const char* name)
 {
diff --git a/js/src/jit/mips32/Architecture-mips32.h b/js/src/jit/mips32/Architecture-mips32.h
index 4d72f76..a4c3aee 100644
--- a/js/src/jit/mips32/Architecture-mips32.h
+++ b/js/src/jit/mips32/Architecture-mips32.h
@@ -12,23 +12,6 @@
 #include <limits.h>
 #include <stdint.h>
 
-#define REGISTERS_NAMES         \
-    { "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3", \
-      "t0",   "t1", "t2", "t3", "t4", "t5", "t6", "t7", \
-      "s0",   "s1", "s2", "s3", "s4", "s5", "s6", "s7", \
-      "t8",   "t9", "k0", "k1", "gp", "sp", "fp", "ra"};
-
-#define REGISTERS_ALLOCATABLE   14
-#define REGISTERS_ARGREGMASK    SharedArgRegMask
-
-#define REGISTERS_JSCALLMASK    \
-    (1 << Registers::a2) |      \
-    (1 << Registers::a3);
-
-#define REGISTERS_CALLMASK      \
-    (1 << Registers::v0) |      \
-    (1 << Registers::v1);  // used for double-size returns
-
 #include "jit/mips-shared/Architecture-mips-shared.h"
 
 #include "js/Utility.h"
diff --git a/js/src/jit/mips32/Assembler-mips32.h b/js/src/jit/mips32/Assembler-mips32.h
index e1d8893..b986390 100644
--- a/js/src/jit/mips32/Assembler-mips32.h
+++ b/js/src/jit/mips32/Assembler-mips32.h
@@ -7,13 +7,6 @@
 #ifndef jit_mips32_Assembler_mips32_h
 #define jit_mips32_Assembler_mips32_h
 
-// NOTE: Don't use these macros directly
-// CallTempNonArgRegs
-#define CALL_TEMP_NON_ARG_REGS  \
-    { t0, t1, t2, t3, t4 };
-// NumIntArgRegs
-#define NUM_INT_ARG_REGS        4;
-
 #include "jit/mips-shared/Assembler-mips-shared.h"
 
 #include "jit/mips32/Architecture-mips32.h"
@@ -24,6 +17,9 @@ namespace jit {
 static MOZ_CONSTEXPR_VAR Register CallTempReg4 = t4;
 static MOZ_CONSTEXPR_VAR Register CallTempReg5 = t5;
 
+static MOZ_CONSTEXPR_VAR Register CallTempNonArgRegs[] = { t0, t1, t2, t3, t4 };
+static const uint32_t NumCallTempNonArgRegs = mozilla::ArrayLength(CallTempNonArgRegs);
+
 class ABIArgGenerator
 {
     unsigned usedArgSlots_;
@@ -159,6 +155,42 @@ class Assembler : public AssemblerMIPSShared
     static int32_t ExtractCodeLabelOffset(uint8_t* code);
 }; // Assembler
 
+static const uint32_t NumIntArgRegs = 4;
+
+static inline bool
+GetIntArgReg(uint32_t usedArgSlots, Register* out)
+{
+    if (usedArgSlots < NumIntArgRegs) {
+        *out = Register::FromCode(a0.code() + usedArgSlots);
+        return true;
+    }
+    return false;
+}
+
+// Get a register in which we plan to put a quantity that will be used as an
+// integer argument. This differs from GetIntArgReg in that if we have no more
+// actual argument registers to use we will fall back on using whatever
+// CallTempReg* don't overlap the argument registers, and only fail once those
+// run out too.
+static inline bool
+GetTempRegForIntArg(uint32_t usedIntArgs, uint32_t usedFloatArgs, Register* out)
+{
+    // NOTE: We can't properly determine which regs are used if there are
+    // float arguments. If this is needed, we will have to guess.
+    MOZ_ASSERT(usedFloatArgs == 0);
+
+    if (GetIntArgReg(usedIntArgs, out))
+        return true;
+    // Unfortunately, we have to assume things about the point at which
+    // GetIntArgReg returns false, because we need to know how many registers it
+    // can allocate.
+    usedIntArgs -= NumIntArgRegs;
+    if (usedIntArgs >= NumCallTempNonArgRegs)
+        return false;
+    *out = CallTempNonArgRegs[usedIntArgs];
+    return true;
+}
+
 static inline uint32_t
 GetArgStackDisp(uint32_t usedArgSlots)
 {
diff --git a/js/src/jit/mips64/Architecture-mips64.cpp b/js/src/jit/mips64/Architecture-mips64.cpp
index a69f22a..28c60d1 100644
--- a/js/src/jit/mips64/Architecture-mips64.cpp
+++ b/js/src/jit/mips64/Architecture-mips64.cpp
@@ -11,6 +11,23 @@
 namespace js {
 namespace jit {
 
+const char * const Registers::RegNames[] = { "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3",
+                                             "a4",   "a5", "a6", "a7", "t0", "t1", "t2", "t3",
+                                             "s0",   "s1", "s2", "s3", "s4", "s5", "s6", "s7",
+                                             "t8",   "t9", "k0", "k1", "gp", "sp", "fp", "ra" };
+
+const uint32_t Allocatable = 22;
+
+const Registers::SetType Registers::ArgRegMask =
+    Registers::SharedArgRegMask |
+    (1 << a4) | (1 << a5) | (1 << a6) | (1 << a7);
+
+const Registers::SetType Registers::JSCallMask =
+    (1 << Registers::v1);
+
+const Registers::SetType Registers::CallMask =
+    (1 << Registers::v0);
+
 FloatRegisters::Encoding
 FloatRegisters::FromName(const char* name)
 {
diff --git a/js/src/jit/mips64/Architecture-mips64.h b/js/src/jit/mips64/Architecture-mips64.h
index ffdaf0a..4d82f9a 100644
--- a/js/src/jit/mips64/Architecture-mips64.h
+++ b/js/src/jit/mips64/Architecture-mips64.h
@@ -12,23 +12,6 @@
 #include <limits.h>
 #include <stdint.h>
 
-#define REGISTERS_NAMES         \
-    { "zero", "at", "v0", "v1", "a0", "a1", "a2", "a3", \
-      "a4",   "a5", "a6", "a7", "t0", "t1", "t2", "t3", \
-      "s0",   "s1", "s2", "s3", "s4", "s5", "s6", "s7", \
-      "t8",   "t9", "k0", "k1", "gp", "sp", "fp", "ra"};
-
-#define REGISTERS_ALLOCATABLE   22
-#define REGISTERS_ARGREGMASK    \
-    SharedArgRegMask |          \
-    (1 << a4) | (1 << a5) | (1 << a6) | (1 << a7);
-
-#define REGISTERS_JSCALLMASK    \
-    (1 << Registers::v1);
-
-#define REGISTERS_CALLMASK      \
-    (1 << Registers::v0);
-
 #include "jit/mips-shared/Architecture-mips-shared.h"
 
 #include "js/Utility.h"
diff --git a/js/src/jit/mips64/Assembler-mips64.h b/js/src/jit/mips64/Assembler-mips64.h
index 5dc003a..fc55787 100644
--- a/js/src/jit/mips64/Assembler-mips64.h
+++ b/js/src/jit/mips64/Assembler-mips64.h
@@ -7,13 +7,6 @@
 #ifndef jit_mips64_Assembler_mips64_h
 #define jit_mips64_Assembler_mips64_h
 
-// NOTE: Don't use these macros directly
-// CallTempNonArgRegs
-#define CALL_TEMP_NON_ARG_REGS  \
-    { t0, t1, t2, t3 };
-// NumIntArgRegs
-#define NUM_INT_ARG_REGS        8;
-
 #include "jit/mips-shared/Assembler-mips-shared.h"
 
 #include "jit/mips64/Architecture-mips64.h"
@@ -24,6 +17,9 @@ namespace jit {
 static MOZ_CONSTEXPR_VAR Register CallTempReg4 = a4;
 static MOZ_CONSTEXPR_VAR Register CallTempReg5 = a5;
 
+static MOZ_CONSTEXPR_VAR Register CallTempNonArgRegs[] = { t0, t1, t2, t3 };
+static const uint32_t NumCallTempNonArgRegs = mozilla::ArrayLength(CallTempNonArgRegs);
+
 class ABIArgGenerator
 {
     unsigned usedArgSlots_;
@@ -161,9 +157,20 @@ class Assembler : public AssemblerMIPSShared
     static int64_t ExtractCodeLabelOffset(uint8_t* code);
 }; // Assembler
 
+static const uint32_t NumIntArgRegs = 8;
 static const uint32_t NumFloatArgRegs = NumIntArgRegs;
 
 static inline bool
+GetIntArgReg(uint32_t usedArgSlots, Register* out)
+{
+    if (usedArgSlots < NumIntArgRegs) {
+        *out = Register::FromCode(a0.code() + usedArgSlots);
+        return true;
+    }
+    return false;
+}
+
+static inline bool
 GetFloatArgReg(uint32_t usedArgSlots, FloatRegister* out)
 {
     if (usedArgSlots < NumFloatArgRegs) {
@@ -173,6 +180,30 @@ GetFloatArgReg(uint32_t usedArgSlots, FloatRegister* out)
     return false;
 }
 
+// Get a register in which we plan to put a quantity that will be used as an
+// integer argument. This differs from GetIntArgReg in that if we have no more
+// actual argument registers to use we will fall back on using whatever
+// CallTempReg* don't overlap the argument registers, and only fail once those
+// run out too.
+static inline bool
+GetTempRegForIntArg(uint32_t usedIntArgs, uint32_t usedFloatArgs, Register* out)
+{
+    // NOTE: We can't properly determine which regs are used if there are
+    // float arguments. If this is needed, we will have to guess.
+    MOZ_ASSERT(usedFloatArgs == 0);
+
+    if (GetIntArgReg(usedIntArgs, out))
+        return true;
+    // Unfortunately, we have to assume things about the point at which
+    // GetIntArgReg returns false, because we need to know how many registers it
+    // can allocate.
+    usedIntArgs -= NumIntArgRegs;
+    if (usedIntArgs >= NumCallTempNonArgRegs)
+        return false;
+    *out = CallTempNonArgRegs[usedIntArgs];
+    return true;
+}
+
 static inline uint32_t
 GetArgStackDisp(uint32_t usedArgSlots)
 {
