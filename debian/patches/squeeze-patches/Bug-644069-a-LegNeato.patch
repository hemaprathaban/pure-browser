From: Boris Zbarsky <bzbarsky@mit.edu>
Date: Wed, 13 Apr 2011 17:19:52 -0700
Subject: Bug 644069, a=LegNeato

---
 content/base/src/nsXMLHttpRequest.cpp |   30 +++++++++++++++---------------
 1 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
index 6aa3b9b..5fbe543 100644
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -937,39 +937,39 @@ nsAccessControlLRUCache::GetEntry(nsIURI* aURI,
     return nsnull;
   }
 
-  if (!mTable.Put(key, entry)) {
-    // Failed, clean up the new entry.
-    delete entry;
-
-    NS_WARNING("Failed to add entry to the access control cache!");
-    return nsnull;
-  }
-
-  PR_INSERT_LINK(entry, &mList);
-
-  NS_ASSERTION(mTable.Count() <= ACCESS_CONTROL_CACHE_SIZE + 1,
+  NS_ASSERTION(mTable.Count() <= ACCESS_CONTROL_CACHE_SIZE,
                "Something is borked, too many entries in the cache!");
 
   // Now enforce the max count.
-  if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
+  if (mTable.Count() == ACCESS_CONTROL_CACHE_SIZE) {
     // Try to kick out all the expired entries.
     PRTime now = PR_Now();
     mTable.Enumerate(RemoveExpiredEntries, &now);
 
     // If that didn't remove anything then kick out the least recently used
     // entry.
-    if (mTable.Count() > ACCESS_CONTROL_CACHE_SIZE) {
+    if (mTable.Count() == ACCESS_CONTROL_CACHE_SIZE) {
       CacheEntry* lruEntry = static_cast<CacheEntry*>(PR_LIST_TAIL(&mList));
       PR_REMOVE_LINK(lruEntry);
 
       // This will delete 'lruEntry'.
       mTable.Remove(lruEntry->mKey);
 
-      NS_ASSERTION(mTable.Count() == ACCESS_CONTROL_CACHE_SIZE,
+      NS_ASSERTION(mTable.Count() == ACCESS_CONTROL_CACHE_SIZE - 1,
                    "Somehow tried to remove an entry that was never added!");
     }
   }
   
+  if (!mTable.Put(key, entry)) {
+    // Failed, clean up the new entry.
+    delete entry;
+
+    NS_WARNING("Failed to add entry to the access control cache!");
+    return nsnull;
+  }
+
+  PR_INSERT_LINK(entry, &mList);
+
   return entry;
 }
 
@@ -1008,7 +1008,7 @@ nsAccessControlLRUCache::RemoveExpiredEntries(const nsACString& aKey,
   aValue->PurgeExpired(*now);
   
   if (aValue->mHeaders.IsEmpty() &&
-      aValue->mHeaders.IsEmpty()) {
+      aValue->mMethods.IsEmpty()) {
     // Expired, remove from the list as well as the hash table.
     PR_REMOVE_LINK(aValue);
     return PL_DHASH_REMOVE;
